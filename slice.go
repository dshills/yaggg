package main

/*
Generate a slice container for custom types with a set of useful functions

SliceType is used to define a new container for a user Type.
The slice will be named SliceType.Slice
The type should be defined in user code and it's name set as SliceType.Type
The generated file will use the package SliceType.Package

SliceType.Fields is an optional map of user struct fields and types
If defined a set of extract functions will be defined that allow a slice of the fields to be returned.
type MyType struct {
	I64 int64
}
setting Fields["I64"] = "int64" will generate an ExtractI64() []int64 function. When run on the
collection will return a new slice with all the I64 values.

The user Type must implement 3 functions in the following forms:

func (a MyType)Cmp(b MyType) int
Cmp must return 0 for equality, 1 when a > b, -1 when a < b

func (a MyType)Clone() MyType
Clone must return a deep copy of MyType

func (a MyType)Clear() MyType
Clear must return a valid empty MyType

*/

import (
	"io"
	"text/template"
)

// A SliceType describes the types for code generation
type SliceType struct {
	Package string // package name for generated code
	Slice   string // name for the slice of Types
	Type    string // name of the Type
	Fields  map[string]string
}

// Generate will write the slice functions to w
func (st SliceType) Generate(w io.Writer) (err error) {
	t := template.Must(template.New("Slice").Parse(sliceTmpl))
	err = t.Execute(w, st)
	return
}

const sliceTmpl = `package {{.Package}}

import (
	"sort"
)

/** This is an autogenerated file. Do Not change **/

// A {{.Slice}} is a slice of {{.Type}}s
type {{.Slice}} []{{.Type}}

// Len will satisfy the sort.Interface
func (e {{.Slice}}) Len() int { return len(e) }

// Less will satisfy the sort.Interface
func (e {{.Slice}}) Less(i, j int) bool {
	if e[i].Cmp(e[j]) > 0 {
		return false
	}
	return true
}

// Swap will satisfy the sort.Interface
func (e {{.Slice}}) Swap(i, j int) { e[i], e[j] = e[j], e[i] }

// Sort will sort {{.Slice}} using the .Cmp function
func (e {{.Slice}}) Sort() { sort.Sort(e) }

// SSearch will return the index of the first occurence of n for a sorted {{.Slice}}
func (e {{.Slice}}) SSearch(n {{.Type}}) int {
	return sort.Search(len(e), func(i int) bool { return e[i].Cmp(n) != -1 })
}

// Search will return the index of the first occurence of n in {{.Slice}}
func (e {{.Slice}}) Search(n {{.Type}}) int {
	for i, v := range e {
		if v.Cmp(n) == 0 {
			return i
		}
	}
	return len(e)
}

// Filter will return a new {{.Slice}} of {{.Type}} that match by calling the function fx
func (e {{.Slice}}) Filter(fx func(n {{.Type}}) bool) {{.Slice}} {
	f := make({{.Slice}}, 0, len(e))
	for _, v := range e {
		if fx(v) {
			f = append(f, v)
		}
	}
	return f
}

// FilterNot will return a new {{.Slice}} of {{.Type}} that do not match by calling the function fx
func (e {{.Slice}}) FilterNot(fx func(n {{.Type}}) bool) {{.Slice}} {
	f := make({{.Slice}}, 0, len(e))
	for _, v := range e {
		if fx(v) == false {
			f = append(f, v)
		}
	}
	return f
}

// Map will run function fx on all items in {{.Slice}}
func (e {{.Slice}}) Map(fx func(n {{.Type}}) {{.Type}}) {
	for i := range e {
		e[i] = fx(e[i])
	}
}

// Cut will remove items i through j-1
// The Clear function wil be called to insure memory is properly handled
func (e *{{.Slice}}) Cut(i, j int) {
	z := *e // copy slice header
	copy(z[i:], z[j:])
	for k, n := len(z)-j+i, len(z); k < n; k++ {
		z[k].Clear()
	}
	z = z[:len(z)-j+i]
	*e = z
}

// Delete will remove item i
// The Clear function wil be called on the removed item to insure memory is properly handled
func (e *{{.Slice}}) Delete(i int) {
	z := *e // copy the slice header
	end := len(z) - 1
	e.Swap(i, end)
	copy(z[i:], z[i+1:])
	z[end] = z[end].Clear()
	z = z[:end]
	*e = z
}

// Insert will place a new item at position i
func (e *{{.Slice}}) Insert(n {{.Type}}, i int) {
	z := *e // copy the slice header
	z = append(z, {{.Type}}{})
	copy(z[i+1:], z[i:])
	z[i] = n
	*e = z
}

// Append will add a new item at the end of {{.Slice}}
func (e *{{.Slice}}) Append(n {{.Type}}) {
	*e = append(*e, n)
}

// Prepend will add a new item at the beginning of {{.Slice}}
func (e *{{.Slice}}) Prepend(n {{.Type}}) {
	e.Insert(n, 0)
}

// Clone will return a copy of {{.Slice}} calling the Clone function on each item
func (e {{.Slice}}) Clone() {{.Slice}} {
	f := make({{.Slice}}, len(e))
	for i := range e {
		f[i] = e[i].Clone()
	}
	return f
}

{{range $n, $t := .Fields}}
func (e {{.Slice}}) Extract{{$n}}() []{{$t}} {
	ext := make([]{{$t}}, 0, len(e))
	for _, v := range e {
		ext = append(ext, v.{{$n}})
	}
}
{{end}}`
